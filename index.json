[{"content":"\n\n## 背景介绍\n\nLet's Encrypt 目前已经支持 Wildcard (泛域名) 证书，\n","cover":"","link":"docker-lets-encrypt.html","preview":"\u003cp\u003e免费的 Let\u0026rsquo;s Encrypt 证书生成过程略微繁琐，由于该过程使用 ACME 协议，这里使用 ACME.sh 的 docker 镜像来简化证书生成与续期的过程。\u003c/p\u003e\n","title":"使用 Docker 简化 Let’s Encrypt 证书生成与续期"},{"content":"\n\n2016 几乎一整年没有更新过博客，平时都在忙些什么呢？空闲时候偶尔会有一些奇怪想法，但大多数都在一开始就被否定，原因是觉得根本没有用处，造轮子是需要花时间的。如果的确有实际需要而没有特别好的现成品，我就会很兴奋，想马上就去实现，想比别人做的更好，更简单易用。希望以后依然能这样一直保持好奇与创作冲动，不枉自己喜欢过的那些电影，听过的音乐，还有一切美好。\n\n### # 一个内网映射服务的实现\n\n很多时候会有把内网服务映射到外网的需求，好吧，这是个轮子。但想做到配置简单，可视化和易用，才有了这个小工具，可以管理多个映射，监视流量等。项目躺在[这里](https://github.com/imeoer/chole)了，如你所见结局并不好，它还只是个实验性工具，没有做到产品化。开发过程中大概感受到 Node.js 和 Go 在网络开发体验上的一些区别：Node.js 接口虽简单，但异步方式对业务封装来说不够直观，Go 接口丰富，但实现略微繁琐，性能上 Go 比 Node.js 高出一截。\n\n### # SSR 服务管理小工具\n\n有没有觉得不断换梯子很麻烦呢？如果觉得折腾梯子部署，服务器管理繁琐，又或想提供给很多用户使用，那么这个工具会让你觉得超级简单。原本是与小伙伴提的想法，想用来做一些奇怪的事情，最终还是觉得不太合适。Go + Vue + Blueprint 实现，强烈推荐 [Blueprint](http://blueprintjs.com/) 这个 UI 库，画风精致，文档良心，最重要的是它考虑到了键盘支持，以及残障人士的可访问性，国内一堆堆连文档都不完善的 UI 库，有多少又会考虑得到这些呢。[待开源]\n![能显著提高爬梯管理幸福感的工具](/blog/images/2016-side-projects/ssr-host.png)\n\n### # 纸小墨技术阅读应用\n\n一直想有个能日常使用的技术类阅读应用，但试用了一圈，发现这类应用还不够多，也做的还不够好：\n\n1. 推送文章大多质量不太高；\n2. 内容杂乱，筛选感兴趣内容费时；\n3. 排版一般，阅读体验不够；\n4. 会错过很多优秀原文与内容源；\n\n以上，觉得传统的博客订阅也许还是最好的途径，于是就诞生了这么个小应用。React-Native 实现，实际效果并没有想象中那么好，性能和原生应用还是有差距的。具体表现在渲染延迟和 API 支持度不够上，不过依然还是适合用来快速开发和验证想法的。[待完成]\n\n![简单，简单，特别简单的时间线和订阅](/blog/images/2016-side-projects/reader1.png)\n\n![优化过排版的正文，还有一些无关紧要的设置](/blog/images/2016-side-projects/reader2.png)\n\n2017，想无顾忌一点，想多读一些书，想多提升自己。","cover":"/blog/images/2016-side-projects/cover.jpg","link":"2016-side-projects.html","preview":"\u003cp\u003e2016 几乎一整年没有更新过博客，平时都在忙些什么呢？空闲时候偶尔会有一些奇怪想法，但大多数都在一开始就被否定，原因是觉得根本没有用处，造轮子是需要花时间的。如果的确有实际需要而没有特别好的现成品，我就会很兴奋，想马上就去实现，想比别人做的更好，更简单易用。希望以后依然能这样一直保持好奇与创作冲动，不枉自己喜欢过的那些电影，听过的音乐，还有一切美好。\u003c/p\u003e\n","title":"2016 年的一些小折腾"},{"content":"\n\nJavaScript领域发展速度很快，甚至有人认为这已经引起了[负效应](http://www.breck-mckye.com/blog/2014/12/the-state-of-javascript-in-2015/)。一个前端库从早期开发的小玩具，到流行，再到过时，可能也就几个月时间。判断一个工具能否在几年内依然保持活力都快成了一门艺术了。\n\nReact.js在两年前[发布](https://facebook.github.io/react/blog/2013/06/05/why-react.html)时，我刚开始学Angular，React在我看来只是又一个模板库而已。这两年间，Angular得到了[JavaScript开发者](http://www.toptal.com/javascript)的认同，它几乎成了现代前端开发的代名词。我还看到一些很保守的团队都在用它，这让我觉得Angular好像就是未来。\n\n但突然发生了件奇怪的事，Angular好像[成了奥斯本效应的受害者](http://jaxenter.com/angular-2-0-announcement-backfires-112127.html)，或者说它被提前宣布了死亡。Angular团队宣布，Angular 2将会完全不同，基本没有从Angular 1升级迁移的东西，而且Angular 2在接下来的一年里还用不了。这告诉了那些想开发新Web项目的人：你想用一个马上要被淘汰了的框架写项目吗？\n\n开发者们的忧虑影响到了正在建立的React社区，但React总标榜它只是MVC中的视图层(V)，让一些依赖完整MVC框架做开发的人感觉有点失望。如何补充其他部分的功能？自己写吗？还是用别的三方库？要是的话该选哪一个呢？\n\n果然，Facebook(React.js的创始)出了另一个杀手锏：[Flux](https://facebook.github.io/react/blog/2014/05/06/flux.html)工作流，它声称要填补模型层(M)和控制层(C )的功能。Facebook还称Flux只是一种“模式”，不是个框架，他们的Flux实现只是这个模式的一个例子。就像他们所说，这个实现过于简单，但还是要写很多代码和一堆重复的模板才跑得起来。\n\n这时开源社区发力了，一年后便有了各种Flux实现库，甚至都出来[比较他们](https://github.com/voronianski/flux-comparison)的元项目了。Facebook激起了社区的兴趣，不是给出现成的东西，而是鼓励大家提出自己的解决方案，这点很不错。\n\n当你要结合各种库开发一个完整架构时，摆脱了框架的束缚，独立的库还可以在很多地方重用，在自己构建架构的过程中，这个优点很明显。\n\n这便是为什么React相关的东西这么有意思。它们可以很容易地在其他JavaScript环境中实现重用。就算你不打算用React，看看它的生态系统都能受到启发。可以试试强大又容易配置的模块化打包工具[Webpack](http://webpack.github.io/)来简化构建系统，或者用[Babel](https://babeljs.io/)转译器马上开始用ECMAScript 6甚至ECMAScript 7来写代码。\n\n在这篇文章里我会给你概览一遍这些有意思的库和特性，来探索下React整个生态系统吧。\n\n![](/blog/images/react-ecosystem/1.jpg)\n\n## 构建系统\n\n创建一个新的Web项目时，首先要考虑的可能就是构建系统了。它不只是做为个运行脚本的工具，还能优化你的项目结构。一个构建系统必须能包括下面几个最主要功能：\n\n- 管理内部与外部依赖\n- 运行编译器和预处理器（例如CoffeeScript与SASS）\n- 为生产环境优化资源（例如Uglify）\n- 运行开发环境的Web Server，文件监控，浏览器自动刷新\n\n最近几年，[Yeoman](http://yeoman.io/learning/)，[Bower](http://bower.io/)与[Grunt](http://gruntjs.com/)被誉为现代前端开发的三剑客。他们解决了生成基础模板，包管理和各种通用任务问题，后面也很多人从Grunt换到了[Gulp](http://gulpjs.com/)。\n\n在React的生态系统里，基本上可以丢掉这些东西了，不是说你用不到他们，而是说可以用更先进的[Webpack](http://webpack.github.io/)与[NPM](https://www.npmjs.com/)。怎么做到的呢？Webpack是一个模块化打包工具，用它可以在浏览器环境下使用Node.js中常用的[CommonJS](http://en.wikipedia.org/wiki/CommonJS)模块语法。其实它要更简单点，因为你不用为了前端另外学一种包管理方案。只需要用NPM，就可以做到服务端与前端模块的共用。也不用处理JS文件按顺序加载的问题，因为它能够从每个文件的import语法中推测出依赖关系，整个串联成一个可以在浏览器中加载的脚本。\n\n![Webpack](/blog/images/react-ecosystem/2.jpg)\n\n更强大的是Webpack不只像同类工具[Browserify](http://browserify.org/)，它还可以处理其他类型的资源。例如用[加载器](http://webpack.github.io/docs/loaders.html)，可以将任何资源文件转换成JavaScript函数，去内联或加载引用到的文件。用不着手工预处理还有从HTML中引用资源了，只要在JavaScript中`require`CSS/SASS/LESS文件就好了，Webpack会根据[配置文件](https://github.com/webpack/example-app/blob/master/webpack.config.js)的描述去搞定一切。它还提供了个开发环境的Web Server，文件监控器，你可以在`package.json`中使用`scripts`域去定义一个任务：\n\n``` json\n{\n  \"name\": \"react-example-filmdb\",\n  \"version\": \"0.0.1\",\n  \"description\": \"Isomorphic React + Flux film database example\",\n  \"main\": \"server/index.js\",\n  \"scripts\": {\n    \"build\": \"./node_modules/.bin/webpack --progress --stats --config ./webpack/prod.config.js\",\n    \"dev\": \"node --harmony ./webpack/dev-server.js\",\n    \"prod\": \"NODE_ENV=production node server/index.js\",\n    \"test\": \"./node_modules/.bin/karma start --single-run\",\n    \"postinstall\": \"npm run build\"\n  }\n  ...\n}\n```\n这些东西就可以代替Gulp与Bower了。当然，还是可以继续用Yeoman去生成应用基础模板的。要是Yeoman生成不了你需要的东西时（其实大多时候也都需要删掉那些用不到的库），还可以从Github上Clone一个基础模板，然后再改改。\n\n## 马上试试新的ECMAScript\n\nJavaScript在这几年有很大改善，移除糟粕稳定语言后，我们看到了很多新特性，ECMAScript 6(ES6)草案已经[定稿](http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts#final_draft)。ECMAScript 7也已纳入标准化日程中，它们的特性也都已经被很多库采用了。\n\n![ECMAScript 7](/blog/images/react-ecosystem/3.jpg)\n\n可能你觉得到IE支持之前都用不上这些JS新特性，但实际我们不需要等浏览器完全支持，ES转译器已经广泛应用了。目前最好的ES转译器是[Babel](https://babeljs.io/)，它能够把ES6+代码转换成ES5，所以你马上就能用上新ES特性了（指已经在Babel中实现的那些，其实一般新出的特性也会很快被支持）。\n\n![Babel](/blog/images/react-ecosystem/4.jpg)\n\n新的JavaScript特性在所有前端框架里都可以用，更新的React能很好的在ES6与ES7下运行。这些新特性可以解决在用React开发时遇到的一些问题。来看下这些改善吧，它们对React项目很有用。稍后我们再看看怎样利用这些语法，来搭配使用React的工具和库。\n\n### ES6 Classes\n\n面向对象编程是一种强大又广泛适用的范式，但在JavaScript里感觉有点不一样。Backbone，Ember，Angular，或React等大多数前端框架都有它们自己的定义类和创建对象的方式。在ES6中，有原生的类支持了，它简洁清晰而不用我们自己实现，例如：\n\n``` javascript\nReact.createClass({\n  displayName: 'HelloMessage',\n  render() {\n    return \u003cdiv\u003eHello {this.props.name}\u003c/div\u003e;\n  }\n})\n```\n\n使用ES6就可以写成：\n\n``` javascript\nclass HelloMessage extends React.Component {\n  render() {\n    return \u003cdiv\u003eHello {this.props.name}\u003c/div\u003e;\n  }\n}\n```\n\n再看个详细的例子：\n\n``` javascript\nReact.createClass({\n  displayName: 'Counter',\n  getDefaultProps: function(){\n    return {initialCount: 0};\n  },\n  getInitialState: function() {\n    return {count: this.props.initialCount}\n  },\n  propTypes: {initialCount: React.PropTypes.number},\n  tick() {\n    this.setState({count: this.state.count + 1});\n  },\n  render() {\n    return (\n      \u003cdiv onClick={this.tick}\u003e\n        Clicks: {this.state.count}\n      \u003c/div\u003e\n    );\n  }\n});\n```\n\nES6可以写成：\n\n``` javascript\nclass Counter extends React.Component {\n  static propTypes = {initialCount: React.PropTypes.number};\n  static defaultProps = {initialCount: 0};\n\n  constructor(props) {\n    super(props);\n    this.state = {count: props.initialCount};\n  }\n\n  state = {count: this.props.initialCount};\n  tick() {\n    this.setState({count: this.state.count + 1});\n  }\n\n  render() {\n    return (\n      \u003cdiv onClick={this.tick.bind(this)}\u003e\n        Clicks: {this.state.count}\n      \u003c/div\u003e\n    );\n  }\n}\n```\n\n在这里不用再写`getDefaultProps`和`getInitialState`这两个React的生命周期函数了。`getDefaultProps`改为了类的静态变量`defaultProps`，初始state也只需要定义在构造函数中。这种方式唯一的缺点是，在[JSX](https://facebook.github.io/react/docs/jsx-in-depth.html)中使用的方法的上下文不会再自动绑定到类实例了，必须用`bind`来[指定](https://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html)。\n\n## 装饰器\n\n装饰器是ES7中的特性。通过一个包装函数，来增强函数或类的行为。例如想为一些组件使用同一个change handler，\n而又不想[inheritance antipattern](http://asserttrue.blogspot.cz/2009/02/inheritance-as-antipattern.html)，则可以用类的装饰器去实现。定义一个装饰器：\n\n``` javascript\naddChangeHandler: function(target) {\n  target.prototype.changeHandler = function(key, attr, event) {\n    var state = {};\n    state[key] = this.state[key] || {};\n    state[key][attr] = event.currentTarget.value;\n    this.setState(state);\n  };\n  return target;\n}\n```\n\n在这里，函数`addChangeHandler`添加了`changeHandler`方法到目标类`target`的实例上。\n\n要应用装饰器，只需要：\n\n``` javascript\nMyClass = addChangeHandler(MyClass)\n```\n\n或者用更优雅的ES7写法：\n\n``` javascript\n@addChangeHandler\nclass MyClass {\n  ...\n}\n```\n\n因为React没有双向数据绑定，在用到input之类的控件时，代码就会比较冗余，`changeHandler`函数则把它简化了。第一个参数表示在state对象中使用的`key`，它将存储input的一个数据对象。第二个参数是属性，它表示input的值。这两个参数在JSX中被传入:\n\n``` javascript\n@addChangeHandler\nclass LoginInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      login: {}\n    };\n  }\n  render() {\n    return (\n      \u003cinput\n        type='text'\n        value={this.state.login.username}\n        onChange={this.changeHandler.bind(this, 'login', 'username')} /\u003e\n      \u003cinput\n        type='password'\n        value={this.state.login.password}\n        onChange={this.changeHandler.bind(this, 'login', 'password')} /\u003e\n    )\n  }\n}\n```\n\n用户名输入框发生改变时，输入框的值会被直接存到`this.state.login.username`中，不需要一个个去写handler了。\n\n## 箭头函数\n\nJavaScript的动态上下文`this`不太直观，成了开发者的常痛了。比如在类里，包装函数中的`this`都被指向了全局变量。要fix这个问题，通常是把`this`存到外部作用域下(例如_this)，然后在内部函数中用它：\n\n``` javascript\nclass DirectorsStore {\n  onFetch(directors) {\n    var _this = this;\n    this.directorsHash = {};\n    directors.forEach(function(x){\n      _this.directorsHash[x._id] = x;\n    })\n  }\n}\n```\n\n在ES6中，函数`function(x) {`可以写成`(x) =\u003e {`。这种箭头方式的函数定义不仅将内部的`this`绑定到了外部作用域，而且看起来很简洁，在写大量异步代码时很有用：\n\n``` javascript\nonFetch(directors) {\n  this.directorsHash = {};\n  directors.forEach((x) =\u003e {\n    this.directorsHash[x._id] = x;\n  })\n}\n```\n\n## 解构赋值\n\nES6中的解构赋值允许在赋值表达式左边写个复合对象：\n\n``` javascript\nvar o = {p: 42, q: true};\nvar {p, q} = o;\n\nconsole.log(p); // 42\nconsole.log(q); // true\n```\n\n在React中有什么实际用处吗？看下面这个例子：\n\n``` javascript\nfunction makeRequest(url, method, params) {\n  var config = {\n    url: url,\n    method: method,\n    params: params\n  };\n  ...\n}\n```\n\n用解构方式，可以一次给几个键赋值。`url, method, params`这些值会被自动赋给有着同名键的对象中。这让代码更不易出错：\n\n``` javascript\nfunction makeRequest(url, method, params) {\n  var config = {url, method, params};\n  ...\n}\n```\n\n解构赋值也可以用来加载一个模块的子集：\n\n``` javascript\nconst {clone, assign} = require('lodash');\nfunction output(data, optional) {\n  var payload = clone(data);\n  assign(payload, optional);\n}\n```\n\n## 函数的默认，剩余，扩展参数\n\n在ES6中函数传参更强大了，可以为函数设置默认参数：\n\n``` javascript\nfunction http(endpoint, method='GET') {\n  console.log(method)\n  ...\n}\n\nhttp('/api') // GET\n```\n\n觉得`arguments`用起来很麻烦？可以把剩余参数写成一个数组：\n\n``` javascript\nfunction networkAction(context, method, ...rest) {\n  // rest is an array\n  return method.apply(context, rest);\n}\n```\n\n要是不想调用`apply()`方法，可以把数组扩展成函数的参数：\n\n``` javascript\nmyArguments = ['foo', 'bar', 123];\nmyFunction(...myArguments);\n```\n\n## Generator与Async函数\n\nGenerator是一种可以暂停执行，保存状态并稍后恢复执行的函数，每次遇到`yield`关键字时，就会暂停执行。Generator写法：\n\n``` javascript\nfunction* sequence(from, to) {\n  console.log('Ready!');\n  while(from \u003c= to) {\n    yield from++;\n  }\n}\n```\n\n调用Generator函数：\n\n``` javascript\n\u003e var cursor = sequence(1,3)\nReady!\n\u003e cursor.next()\n{ value: 1, done: false }\n\u003e cursor.next()\n{ value: 2, done: false }\n\u003e cursor.next()\n{ value: 3, done: false }\n\u003e cursor.next()\n{ value: undefined, done: true }\n```\n\n当调用Generator函数时，会立即执行到第一次遇到的`yield`关键字处暂停。在调用`next()`函数后，返回yield后的表达式的值(value)，然后Generator里再继续执行之后的代码。每次遇到`yield`都返回一个值，在第三次调用`next()`后，Generator函数终止，最后调用的`next()`将返回`{ value: undefined, done: true }`。\n\n当然咯，Generator不只能用来创建数字序列。它能够暂停和恢复函数的执行，这便可以不需要回调函数就完成异步流的控制。\n\n我们用异步函数来证明这一点。一般我们会做些I/O操作，这里为了简单起见，用`setTimeout`模拟。这个异步函数立即返回一个[promise](http://www.toptal.com/javascript/javascript-promises)。（ES6有[原生的promise](http://www.html5rocks.com/en/tutorials/es6/promises/)）：\n\n``` javascript\nfunction asyncDouble(x) {\n  var deferred = Promise.defer();\n  setTimeout(function(){\n    deferred.resolve(x*2);\n  }, 1000);\n  return deferred.promise;\n}\n```\n\n然后写一个消费者函数：\n\n``` javascript\nfunction consumer(generator){\n  var cursor = generator();\n  var value;\n  function loop() {\n    var data = cursor.next(value);\n    if (data.done) {\n      return;\n    } else {\n      data.value.then(x =\u003e {\n        value = x;\n        loop();\n      })\n    }\n  }\n  loop();\n}\n```\n\n这个函数接受Generator函数作为参数，只要`yield`有值，就会继续调用`next()`方法。这个例子中，`yield`的值是promise，所以必须等待promise调用resolve后，再递归调用`loop()`循环。\n\nresolve会调用`then()`方法，把resolve的结果赋值给`value`，value被定义在函数外部，它会被传给下一个`next(value)`。这次next的调用为`yield`产生了一个返回值(即value)。这样可以不用回调函数来写异步调用了：\n\n``` javascript\nfunction* myGenerator(){\n  const data1 = yield asyncDouble(1);\n  console.log(`Double 1 = ${data1}`);\n  const data2 = yield asyncDouble(2);\n  console.log(`Double 2 = ${data2}`);\n  const data3 = yield asyncDouble(3);\n  console.log(`Double 3 = ${data3}`);\n}\n\nconsumer(myGenerator);\n```\n\nGenerator函数`myGenerator`将在每次遇到`yield`时暂停，等待消费者函数的promise去resolve。在控制台每隔1秒的输出：\n\n``` javascript\nDouble 1 = 2\nDouble 2 = 4\nDouble 3 = 6\n```\n\n上面的示例代码不推荐在生产环境中用，可以用更完善的[co](https://github.com/tj/co)库，能很简单地用yield处理异步，还包含了错误处理：\n\n``` javascript\nco(function *(){\n  var a = yield Promise.resolve(1);\n  console.log(a);\n  var b = yield Promise.resolve(2);\n  console.log(b);\n  var c = yield Promise.resolve(3);\n  console.log(c);\n}).catch(function(err){\n  console.error(err.stack);  \n});\n```\n\n在ES7中，将异步处理的改进更近了一步，增加了`async`和`await`关键字，无需使用Generator。上面的例子可以写成：\n\n``` javascript\nasync function (){\n  try {\n    var a = await Promise.resolve(1);\n    console.log(a);\n    var b = await Promise.resolve(2);\n    console.log(b);\n    var c = await Promise.resolve(3);\n    console.log(c);\n  } catch (err) {\n    console.error(err.stack);  \n  }\n};\n```\n\n有了这些特性，不会觉得JavaScript写异步代码麻烦了，而且在任何地方都可以用。\n\nGenerator不仅简洁明了，还能做些用回调很难实现的事。比如Node.js中[koa](http://koajs.com/)Web框架的中间件。koa的目标是替换掉Express，它有个很不错的特性：中间件的上下游都可以对服务端响应做进一步修改。看看这段koa服务器代码：\n\n``` javascript\n// Response time logger middleware\napp.use(function *(next){\n  // Downstream\n  var start = new Date;\n  yield next;\n  // Upstream\n  this.body += ' World';\n  var ms = new Date - start;\n  console.log('%s %s - %s', this.method, this.url, ms);\n});\n\n// Response handler\napp.use(function *(){\n  this.body = 'Hello';\n});\n\napp.listen(3000);  \n```\n\n![Koa](/blog/images/react-ecosystem/5.jpg)\n\n进入第一个中间件时(上游)，遇到yield后，先进入第二个中间件(下游)将响应体设置为`Hello`，然后再从yield恢复执行，继续执行上游中间件代码，为响应体追加了` World`，然后打印了时间日志，在这里上下游共享了相同的上下文(this)。这要比[Express](http://expressjs.com/guide/routing.html)更强大，如果用Express来写的话可能会是这样：\n\n```javascript\nvar start;\n// Downstream middleware\napp.use(function(req, res, next) {\n  start = new Date;\n  next();\n  // Already returned, cannot continue here\n});\n\n// Response\napp.use(function (req, res, next){\n  res.send('Hello World')\n  next();\n});\n\n// Upstream middleware\napp.use(function(req, res, next) {\n  // res already sent, cannot modify\n  var ms = new Date - start;\n  console.log('%s %s - %s', this.method, this.url, ms);\n  next();\n});\n\napp.listen(3000);\n```\n\n也许你已经发现问题了，使用全局的`start`变量在出现并发请求时会产生污染。\n\n用koa时，可以很容易地用Generator做异步操作：\n\n``` javascript\napp.use(function *(){\n  try {\n    const part1 = yield fs.readFile(this.request.query.file1, 'utf8');\n    const part2 = yield fs.readFile(this.request.query.file2, 'utf8');\n    this.body = part1 + part2;\n  } catch (err) {\n    this.status = 404\n    this.body = err;\n  }\n});\n\napp.listen(3000);\n```\n\n可以设想下这个例子在Express中用promise和回调会是什么样子。\n\n![](/blog/images/react-ecosystem/6.jpg)\n\n上面讨论的Node.js这些跟React有关系吗？当然咯，Node是React的首选后端服务器。因为Node也用JavaScript，这样可以前后端共享代码，用来构建[同构](http://nerds.airbnb.com/isomorphic-javascript-future-web-apps/)的React Web应用，稍后会介绍到。\n\n## Flux库\n\nReact很擅长创建视图组件，但我们还需要一种方式去管理数据和整个应用的状态。Flux应用架构被普遍认为是React最好的补充。要是你对Flux还很陌生，建议看看这篇快速[导览](https://facebook.github.io/flux/docs/overview.html)。\n\n![Flux](/blog/images/react-ecosystem/7.jpg)\n\n目前还没有出现大多数人都认同的Flux实现，Facebook官方的[Flux](https://github.com/facebook/flux)实现很多人都觉得很冗余。我们主要关心能不能少写点模板代码，配置方便，并且给多层组件提供些好用的功能，支持服务端渲染等等这些。可以看看[这里](https://github.com/kriasoft/react-starter-kit/issues/22)给这些实现库列出的一些指标。我关注了Alt, Reflux, Flummox, Fluxxor, 和Marty.js。\n\n我选择库的方式并不能说客观，但很有用。[Fluxxor](http://fluxxor.com/)是我发现的第一个库，但现在看起来它有点旧了。[Marty.js](http://martyjs.org/)很有意思，有很多功能，但还是需要写很多模板代码，有些功能看起来比较多余。[Reflux](https://github.com/spoike/refluxjs)看起来蛮有吸引力，但感觉对初学者来说有点难，还缺少合适的文档。[Flummox](http://acdlite.github.io/flummox)和[Alt](http://alt.js.org/)很相似，但Alt不需要写很多模板代码，开发也非常活跃，[文档](http://alt.js.org/docs/)更新块，而且有个[Slack](http://www.reactiflux.com/)社区。所以我选了Alt。\n\n## Alt Flux\n\n![Alt Flux](/blog/images/react-ecosystem/8.jpg)\n\nAlt的Flux实现简单而强大。Facebook的Flux[文档](https://facebook.github.io/flux/docs/overview.html)描述了很多关于dispatcher的东西，但在[Alt](https://github.com/goatslacker/alt)中这些都可以忽略，因为dispatcher被隐式关联到了action，通常不需要写多余代码。只需要关心store，action，component。这三层对应MVC模型：store为模型层，action为控6制层，component为视图层。差异是Flux模型是单向数据流，意味着控制层不能直接修改视图层，而是触发模型层后，视图层被动修改。这对[有些](http://joelhooks.com/blog/2013/04/24/modeling-data-and-state-in-your-angularjs-application/)Angular开发者来说已经是最佳实践了。\n\n1. component初始化action\n2. store监听action然后更新数据\n3. component被绑定到store，当数据更新时就重新渲染\n\n![Alt Flux](/blog/images/react-ecosystem/9.jpg)\n\n## Action\n\n使用Alt库时，action通常有两种写法：自动与手动。自动action用`generateActions`函数创建，它们直接发给dispatcher，手动方法则写成action类的方法，它们可以附带一个payload发给dispatcher。常用例子是自动action通知store有关app的一些事件。其余由手动action负责，它是处理服务端交互的首选方式。\n\nREST API调用这种就属于action，完整流程如下：\n\n1. Component触发action\n2. action创建者发起一个异步服务器请求，把结果作为一个payload发给dispatcher\n3. store监听action，对应的action处理器接收结果，然后store更新它的相应状态\n\n对于AJAX请求，我们可以用[axios](https://github.com/mzabriskie/axios)库，无缝地处理JSON数据和头数据。可以用ES7的`async/await`关键字，免去promise与回调。如果`POST`响应状态不是2XX，抛出错误，然后发出返回的数据或接收到的错误。\n\n看个简单的Alt登录示例，在这里注销action不需要做任何事情，只需要通知store，所以可以自动生成它。登录action是手动的，会把登录数据作为一个参数发给action的创建者。从服务端获取响应后，发出数据，有错误的话就发出错误。\n\n``` javascript\nclass LoginActions {\n  constructor() {\n    // Automatic action\n    this.generateActions('logout');\n  }\n\n  // Manual action\n  async login(data) {\n    try {\n      const response = await axios.post('/auth/login', data);\n      this.dispatch({ok: true, user: response.data});\n    } catch (err) {\n      console.error(err);\n      this.dispatch({ok: false, error: err.data});\n    }\n  }\n}\n\nmodule.exports = (alt.createActions(LoginActions));\n```\n\n## Store\n\nFlux模型的store有两个任务：作为action的处理器，保存状态。继续看看登录例子是怎么做的吧。\n\n创建一个`LoginStore`，有两个状态属性：`user`用于当前登录的用户，`error`用于当前登录相关的错误。为了减少模板代码数量，Alt可以用一个`bindActions`函数绑定所有action到store类。\n\n``` javascript\nclass LoginStore {\n  constructor() {\n    this.bindActions(LoginActions);\n    this.user = null;\n    this.error = null;\n  }\n  ...\n```\n\n处理器定义起来很方便，只需要在对应action名字前加`on`。因此`login`的action由`onLogin`处理。注意action名的首字母是陀峰命名法的大写。在`LoginStore`中，有以下两个处理器，被对应的action调用：\n\n``` javascript\n...\n  onLogin(data) {\n    if (data.ok) {\n      this.user = data.user;\n      this.error = null;\n      router.transitionTo('home');\n    } else {\n      this.user = null;\n      this.error = data.error\n    }\n  }\n\n  onLogout() {\n    this.user = null;\n    this.error = null;\n  }\n}\n```\n\n## Component\n\n通常将store绑定到component的方式是用mixin。但mixin快过时了，需要找个其他方式，有个新方法是使用嵌套的component。将我们的component包装到另一个component里面，它会托管store的监听然后重新调用渲染。component会在`props`中接收到store的状态。这个方法对于[smart and dumb](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0) component的代码组织很有用，是以后的趋势。对于Alt来说，包装component是由AltContainer实现的：\n\n``` javascript\nexport default class Login extends React.Component {\n  render() {\n    return (\n      \u003cAltContainer stores={{LoginStore: LoginStore}}\u003e\n        \u003cLoginPage/\u003e\n      \u003c/AltContainer\u003e\n  )}\n}\n```\n\n`LoginPage` component也用了我们之前介绍过的`changeHandler`装饰器。`LoginStore`的数据用来显示登陆失败后的错误，重新渲染则由`AltContainer`负责。点击登录按钮后执行`login`action，完整的Alt工作流：\n\n``` javascript\n@changeHandler\nexport default class LoginPage extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      loginForm: {}\n    };\n  }\n  login() {\n    LoginActions.login(this.state.loginForm)\n  }\n  render() {\n    return (\n      \u003cAlert\u003e{{this.props.LoginStore.error}}\u003c/Alert\u003e\n      \u003cInput\n        label='Username'\n        type='text'\n        value={this.state.login.username}\n        onChange={this.changeHandler.bind(this, 'loginForm', 'username')} /\u003e\n      \u003cInput\n        label='Password'\n        type='password'\n        value={this.state.login.password}\n        onChange={this.changeHandler.bind(this, 'loginForm', 'password')} /\u003e\n      \u003cButton onClick={this.login.bind(this)}\u003eLogin\u003c/Button\u003e\n  )}\n}\n```\n\n## 同构渲染\n\n同构Web应用是近些年来的热点话题，它能解决传统单页面应用最大的问题：浏览器用JavaScript动态创建HTML，如果浏览器禁用了JavaScript，内容就无法显示了，搜索引擎索引不到Web页面，内容不会出现在搜索结果中。实际上有方法[解决](http://lawsonry.com/2014/05/diy-angularjs-seo-with-phantomjs-the-easy-way/)这个问题，但做的并不够好。同构的方式是通过服务端渲染内容来解决问题。Node.js是服务端的JavaScript，React当然也能运行在服务端。\n\n一些使用单例方式的Flux库，很难做服务端渲染，单例的Flux 在遇到并发请求时，store数据就会变得混乱。一些Flux库用实例来解决这个问题，但需要在代码间传递实例。Alt实际也提供了Flux实例，但它用单例解决服务端渲染问题，它会在每次请求后清空store，以便并发请求时每次store都是初始状态。\n\n`React.renderToString`函数是服务端渲染的核心，整个React应用运行在服务端。服务端生成HTML后响应给浏览器。浏览器JavaScript运行时，再渲染剩余部分。可以用[Iso](https://github.com/goatslacker/iso)库实现这点，它同时也被集成到了Alt中。\n\n首先，我们在服务端用`alt.bootstrap`初始化Flux，这会初始化Flux store数据。然后区分哪个URL对应的渲染哪个component，哪个由客户端`Router`渲染。由于使用`alt`的单例版，在每次渲染完后，需要使用`alt.flush()`初始化store以便为下次请求做好准备。使用`iso`插件，可以把Flux的状态数据序列化到HTML字符串中，以便客户端知道去哪找到这份状态数据：\n\n``` javascript\n// We use react-router to run the URL that is provided in routes.jsx\nvar getHandler = function(routes, url) {\n  var deferred = Promise.defer();\n  Router.run(routes, url, function (Handler) {\n    deferred.resolve(Handler);\n  });\n  return deferred.promise;\n};\n\napp.use(function *(next) {\n  yield next;\n  // We seed our stores with data\n  alt.bootstrap(JSON.stringify(this.locals.data || {}));\n  var iso = new Iso();\n  const handler = yield getHandler(reactRoutes, this.request.url);\n  const node = React.renderToString(React.createElement(handler));\n  iso.add(node, alt.flush());\n  this.render('layout', {html: iso.render()});\n});\n```\n\n在客户端，拿到了服务端的状态数据，用来初始化`alt`的状态。然后可以运行`Router`和`React.render`去更新服务端生成的HTML：\n\n``` javascript\nIso.bootstrap(function (state, _, container) {\n  // Bootstrap the state from the server\n  alt.bootstrap(state)\n  Router.run(routes, Router.HistoryLocation, function (Handler, req) {\n    let node = React.createElement(Handler)\n    React.render(node, container)\n  })\n})\n```\n\n## 一些有用的库\n\n例如CSS布局容器，样式表单，按钮，验证，日期选择器等等。\n\nReact-Bootstrap\n\n![](/blog/images/react-ecosystem/10.jpg)\n\nTwitter的Bootstrap框架应用已经非常普遍，对那些不想花时间写CSS的开发者很有用。特别是在原型开发阶段，Bootstrap不可或缺。要在React中使用Bootatrap，可以试试React-Bootstrap，它使用原生React component重新实现了Bootstrap的jQuery插件。代码简洁易懂：\n\n``` javascript\n\u003cNavbar brand='React-Bootstrap'\u003e\n  \u003cNav\u003e\n    \u003cNavItem eventKey={1} href='#'\u003eLink\u003c/NavItem\u003e\n    \u003cNavItem eventKey={2} href='#'\u003eLink\u003c/NavItem\u003e\n    \u003cDropdownButton eventKey={3} title='Dropdown'\u003e\n      \u003cMenuItem eventKey='1'\u003eAction\u003c/MenuItem\u003e\n      \u003cMenuItem eventKey='2'\u003eAnother action\u003c/MenuItem\u003e\n      \u003cMenuItem eventKey='3'\u003eSomething else here\u003c/MenuItem\u003e\n      \u003cMenuItem divider /\u003e\n      \u003cMenuItem eventKey='4'\u003eSeparated link\u003c/MenuItem\u003e\n    \u003c/DropdownButton\u003e\n  \u003c/Nav\u003e\n\u003c/Navbar\u003e\n```\n\n个人感觉这才是简单易懂的HTML吧。\n\n也可以在Webpack中使用Bootstrap，看你喜欢哪个CSS预处理器。支持自定义引入的Bootstrap组件，可以在CSS代码中使用LESS或SASS的全局变量。\n\n## React Router\n\n![](/blog/images/react-ecosystem/11.jpg)\n\n[React Router](https://github.com/rackt/react-router)几乎已经成了React的路由标准了。它支持嵌套路由，重定向，同构渲染。基于JSX的例子：\n\n``` javascript\n\u003cRouter history={new BrowserHistory}\u003e\n  \u003cRoute path=\"/\" component={App}\u003e\n    \u003cRoute path=\"about\" name=\"about\" component={About}/\u003e\n    \u003cRoute path=\"users\" name=\"users\"  component={Users} indexComponent={RecentUsers}\u003e\n      \u003cRoute path=\"/user/:userId\" name=\"user\" component={User}/\u003e\n    \u003c/Route\u003e\n    \u003cRoute path=\"*\" component={NoMatch}/\u003e\n  \u003c/Route\u003e\n\u003c/Router\u003e\n```\n\nReact Router可以用`Link` component做应用导航，只需要指定路由名称：\n\n``` javascript\n\u003cnav\u003e\n  \u003cLink to=\"about\"\u003eAbout\u003c/Link\u003e\n  \u003cLink to=\"users\"\u003eUsers\u003c/Link\u003e\n\u003c/nav\u003e\n```\n\n还有集成了React-Bootstrap的路由库，不想手写Bootstrap的`active`类，可以用[react-router-bootstrap](https://github.com/react-bootstrap/react-router-bootstrap)：\n\n``` javascript\n\u003cNav\u003e\n  \u003cNavItemLink to=\"about\"\u003eAbout\u003c/NavItemLink\u003e\n  \u003cNavItemLink to=\"users\"\u003eUsers\u003c/NavItemLink\u003e\n\u003c/Nav\u003e\n```\n\n## Formsy-React\n\n表单开发通常都比较麻烦，用[formsy-react](https://github.com/christianalfoni/formsy-react)来简化一下吧，它可以用来管理验证和数据模型。Formsy-React不包含实际的表单输入，而是推荐用户自己写(这是正确的)。如果只用通用表单，可以用[formsy-react-components](formsy-react-components)。它包括了Bootstrap类：\n\n``` javascript\nimport Formsy from 'formsy-react';\nimport {Input} from 'formsy-react-components';\nexport default class FormsyForm extends React.Component {\n  enableButton() {\n    this.setState({canSubmit: true});\n  }\n  disableButton() {\n    this.setState({canSubmit: true});\n  }\n  submit(model) {\n    FormActions.saveEmail(model.email);\n  }\n  render() {\n    return (\n      \u003cFormsy.Form onValidSubmit={this.submit} onValid={this.enableButton} onInvalid={this.disableButton}\u003e\n        \u003cInput\n          name=\"email\"\n          validations=\"isEmail\"\n          validationError=\"This is not a valid email\"\n          required/\u003e\n        \u003cbutton type=\"submit\" disabled={!this.state.canSubmit}\u003eSubmit\u003c/button\u003e\n      \u003c/Formsy.Form\u003e\n  )}\n}\n```\n\n## 日期与选择器\n\n日期与选择器组件算是UI库的锦上添花了，遗憾的是这两个组件在Bootstrap 3上被移除了，因为它们对于一个通用CSS框架来说比较特殊了。不过我发现了两个不错的代替：[react-pikaday](https://github.com/thomasboyt/react-pikaday)和[react-select](https://github.com/JedWatson/react-select)。我尝试过10多个库，这两个总体来说很不错。非常易用：\n\n``` javascript\nimport Pikaday from 'react-pikaday';\nimport Select from 'react-select';\n\nexport default class CalendarAndTypeahead extends React.Component {\n  constructor(props){\n    super(props);\n    this.options = [\n      { value: 'one', label: 'One' },\n      { value: 'two', label: 'Two' }\n    ];\n  }\n  dateChange(date) {\n    this.setState({date: date});\n  },\n  selectChange(selected) {\n    this.setState({selected: selected});\n  },\n  render() {\n    return (\n      \u003cPikaday\n        value={this.state.date}\n        onChange={this.dateChange} /\u003e\n      \u003cSelect\n        name=\"form-field-name\"\n        value={this.state.selected}\n        options={this.options}\n        onChange={selectChange} /\u003e\n  )}\n}\n```\n\n## 总结 - React.js\n\n这篇文章介绍了目前Web开发的一些技术与框架。有些是React相关的，因为React的开放性，它们也能被用在其他环境。有时候技术进步总会被对新事物的恐惧所阻碍，我希望这篇文章可以打消你对尝试React, Flux和新的ECMAScript的疑虑。\n\n![](/blog/images/react-ecosystem/12.jpg)\n\n要是感兴趣，可以看看我用以上技术构建的[示例应用](https://react-example-filmdb.herokuapp.com/)。源码在[Github](https://github.com/tomaash/react-example-filmdb)上。\n\n感谢能坚持阅读到这里 :)\n\n\u003e 本文译自2015年年中的[《Navigating the React.JS Ecosystem》](http://www.toptal.com/react/navigating-the-react-ecosystem) - [Tomas Holas](http://www.toptal.com/resume/tomas-holas)，对原文有理解性改动，水平有限，欢迎提出意见。:)\n","cover":"/blog/images/react-ecosystem/1.jpg","link":"navigating-the-react-ecosystem.html","preview":"","title":"React.js生态系统概览 [译]"},{"content":"\n\n因为开发与日常用系统都是Linux，偶尔需要给自己的Android手机刷机，但国内各大论坛上给出的刷机工具大都是Windows版的，在虚拟机下操作又不太方便，于是打算在Linux下刷机，经过一时半会的折腾，记录下具体的操作步骤。\n\n### 启用USB调试\n\n打开`设置`\u003e`关于手机`，点击`版本号`7次，回退至`设置`可以看到菜单中出现`开发者选项`，进入后打开`USB调试`选项。\n\n### 创建USB配置\n\n以Root权限创建`/etc/udev/rules.d/51-android.rules`文件，内容为：\n\n``` shell\nSUBSYSTEM==\"usb\" ENV{DEVTYPE}==\"usb_device\", MODE=\"0666\"\n```\n\n执行`sudo chmod a+r /etc/udev/rules.d/51-android.rules`命令为该配置文件增加读权限。\n\n执行`sudo /etc/init.d/udev restart`使配置文件生效。\n\n### 查看设备ID号\n\n用USB线将手机连接后，执行`lsusb`命令查看连接的USB设备信息：\n\n```shell\n...\nBus 001 Device 013: ID 2a70:9011\n...\n```\n\n找到手机设备的一行，在这里`2a70`就是设备ID，将`0x2a70`追加到`~/.android/adb_usb.ini`文件中。\n\n### 安装ADB与FASTBOOT命令行工具 (Ubuntu)\n\nADB(Android Debug Bridge)是一个开发工具，帮助Android设备与PC通信，使用USB线或WIFI方式连接后可以用它操作手机。\n\nFastboot是一种用USB线连接的刷机方式(线刷)，它比Recovery(卡刷)更底层。\n\n``` shell\nsudo add-apt-repository ppa:nilarimogard/webupd8\nsudo apt-get update\nsudo apt-get install android-tools-adb android-tools-fastboot\n```\n\n### 连接测试\n\n用USB线将手机连接后，执行`sudo adb devices`，可以看到：\n\n``` shell\n* daemon not running. starting it now on port 5037 *\n* daemon started successfully *\nList of devices attached\n\n0403502001011000    device\n```\n\n若看到`no permissions`，需要在手机上勾选`允许连接USB调试`再试。\n\n### 愉快的玩机\n\n万事具备，接下来就可以用`adb`与`fastboot`愉快的玩机啦，以下几个有趣的命令：\n\n- 安装应用：`adb install -r \u003cname\u003e.apk`\n- 执行Shell命令：`adb shell \u003ccommand\u003e`\n- 模拟按键：`adb shell input keyevent \u003cvalue\u003e`\n- 截屏：`adb shell screencap \u003cpath\u003e.png`\n- 录像：`adb shell screenrecord \u003cpath\u003e.mp4`\n\n### 常用刷机步骤\n\n- 在开机状态下执行`adb reboot bootloader`命令，在手机重启后进入Fastboot模式。\n- 在Fastboot模式下执行`fastboot devices`查看连接的手机。\n- 执行`fastboot flash recovery \u003crecovery_path\u003e.img`命令刷入Recovery。\n- 执行`fastboot boot \u003crecovery_path\u003e.img`命令免刷进入Recovery\n\n使用许多第三方的Recovery就可以试试各种刷机啦。\n","cover":"","link":"linux-android-adb.html","preview":"\u003cp\u003e因为开发与日常用系统都是Linux，偶尔需要给自己的Android手机刷机，但国内各大论坛上给出的刷机工具大都是Windows版的，在虚拟机下操作又不太方便，于是打算在Linux下刷机，经过一时半会的折腾，记录下具体的操作步骤\u003c/p\u003e\n","title":"Linux下的Android刷机"},{"content":"\n\n《Understanding ECMAScript 6》是一本在[Leanpub](https://leanpub.com/understandinges6/read)发售的开源电子书，较为详细的介绍了ES5的一些不足与在ES6中的改进以及新特性，计划慢慢读完这本书，在这里做一些笔记。\n\n# 基础部分\n\n## 更好的Unicode支持\n\n这里有一篇阮一峰关于JS中Unicode的[基础介绍](http://www.ruanyifeng.com/blog/2014/12/unicode.html)。在ES5中，字符串中每一个字符由16位编码表示，即每个字符占用2个字节，这导致一些超过该16位编码范围的字符占用4个字节来表示，因此当字符串包含这些字符时，长度与位置计算会产生偏差：\n\n``` javascript\nvar text = \"𠮷a\"; //𠮷字超过16位编码\n// ES5\ntext.length; // 3\ntext.charCodeAt(0); // 55362\ntext.charCodeAt(1); // 57271\ntext.charCodeAt(2); // 97\ntext.charAt(0); // \"\"\n\"\\u20BB7\"; // \"7\"， 被拆开为\\u20BB与\\u7，其中\\u20BB不可打印\n// ES6\nArray.from(text).length; // 2\ntext.codePointAt(0); // 134071\ntext.codePointAt(1); // 57271\ntext.codePointAt(2); // 97\ntext.at(0); // \"𠮷\"\nString.fromCodePoint(134071); // \"𠮷\"\n\"\\u{20BB7}\"; // \"𠮷\"\n```\n\n这个字符在Unicode中有两种表示方法，`'\\u01D1'`与`'\\u004F\\u030C'`，分别为单一与复合表示方法，虽然表示同一字符，但在ES5中并不相等，ES6中的normalize()函数用于将该类字符正规化：\n\n``` javascript\n// ES5\n'\\u01D1'==='\\u004F\\u030C' // false\n// ES6\n'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize(); // true\n```\n\n## 正则表达式的改进\n\n新增正则对象初始化方式\n\n```javascript\n// ES5\nnew RegExp('a', 'i'); // 只可用string初始化\n// ES6\nnew RegExp(/a/i).flags; // 'i', 可用正则对象初始化，新增flags属性\n```\n\n新增u标识符用于更好的Unicode支持\n\n``` javascript\nvar text = \"𠮷\";\n// ES5\n/^.$/.test(text); // false\n// ES6\n/^.$/u.test(text); // true，支持u标识符，可以正确匹配4字节的字符\n```\n\n新增的y标识符用于在每次匹配时都从开始位置匹配\n``` javascript\nvar text = \"aaa_aa_a\";\n// ES5\nvar r1 = /a+/g;\nr1.exec(text); // [\"aaa\"]\nr1.exec(text); // [\"aa\"]\n// ES6\nvar r2 = /a+/y;\nr2.exec(text); // [\"aaa\"]\nr2.exec(text); // null\nr2.sticky; // true\n```\n\n## 新增的字符串函数\n\n``` javascript\nvar msg = \"Hello\";\nmsg.startsWith(\"He\"); // true\nmsg.endsWith(\"o\"); // true\nmsg.includes(\"ll\"); // true\nmsg.repeat(3); // \"HelloHelloHello\"\n```\n\n## Object.is\n\n更加严格的值比较方法：\n\n``` javascript\n+0 === -0; // true\nNaN === NaN; // false\n\nObject.is(+0, -0); // false\nObject.is(NaN, NaN); // true\n```\n\n## Let声明\n\nJS中没有块作用域，且由于变量提升(hoisted)问题，在块中声明的变量会被提升到函数顶部，即在该函数内块中声明变量可以在整个函数中被访问到：\n\n``` javascript\nfunction getValue(condition) {\n    if (condition) {\n        var value = \"blue\";\n        return value;\n    } else {\n        return null;\n    }\n}\n```\n\n实际会被解释为：\n\n``` javascript\nfunction getValue(condition) {\n    var value;\n    if (condition) {\n        value = \"blue\";\n        return value;\n    } else {\n        return null;\n    }\n}\n```\n\nJS新增let声明方式，限制变量只能在块级范围内使用：\n\n``` javascript\nfunction getValue(condition) {\n    if (condition) {\n        let value = \"blue\"; // 只在该if条件下能被访问\n        return value;\n    } else {\n        return null;\n    }\n}\n```\n\n由于let的特性，之前为了解决循环时因共享变量问题使用的闭包方式：\n\n``` javascript\nvar funcs = [];\nfor (var i=0; i \u003c 10; i++) {\n    funcs.push((function(value) {\n        return function() {\n            console.log(value);\n        }\n    }(i)));\n}\nfuncs.forEach(function(func) {\n    func();\n});\n```\n\n可以改为：\n\n``` javascript\nvar funcs = [];\nfor (let i=0; i \u003c 10; i++) {\n    funcs.push(function() { console.log(i); });\n}\nfuncs.forEach(function(func) {\n    func();\n})\n```\n\n\u003e 好吧，表示细节好多，先读一遍阮一峰的《ECMAScript 6入门》 _(:з」∠)_\n","cover":"","link":"understanding-es6.html","preview":"\u003cp\u003e《Understanding ECMAScript 6》是一本在Leanpub发售的开源电子书，较为详细的介绍了ES5的一些不足与在ES6中的改进以及新特性，计划慢慢读完这本书，在这里做一些笔记\u003c/p\u003e\n","title":"读书笔记 - 《Understanding ECMAScript 6》"},{"content":"\n\n\u003e 题图来自Pixiv站画师TID作品《Sunny Rain》。\n\n2014年上半年，我和同班毕业的小伙伴发起了一个业余小组的内容发布平台项目。创建一个类似[Medium](https://medium.com/)、[简书](http://jianshu.io/)的写作与阅读平台，专注改善文章撰写、阅读的交互体验，优化知识类文章发布与分享方式。\n\n前端后端,与两大移动端开发各一位同学负责，技术栈有Backbone，Node.js，Python，Golang，MongoDB。我们有每周末的例会，探讨问题同步进度，用Google Doc记录想法，Trello管理任务。\n\n前期设计到前后端基础实现断断续续持续了2个月，中期Web端完成了基本功能，但后期因为项目小组的业余开发时间不充裕，能在同一时间远程探讨问题和联调的时间很少，与上线运营做内容托管的难度，最终放弃，长期搁置该了项目。碰巧自己有记录一些东西的打算，我转而把这个想法写成了现在的[静态博客构建工具](http://www.inkpaper.io/blog/post/2015/03/01/ink-blog-tool.html)，搭建了这个个人博客。\n\nWeb端设计保持简洁，简化了与内容无关的界面元素，以内容组成界面，主题色为黑白，切合阅读风格。\n\n![Web端登录与注册界面](/blog/images/inkpaper/login.png)\n\n尽可能减少视觉干扰，使用顶部Loading Bar与弹出Tooltip提示。\n\n![登录注册通用提示](/blog/images/inkpaper/tip.png)\n\n纯文字元素与留白。\n\n![首页视图](/blog/images/inkpaper/index.png)\n\n![圈子列表设置视图](/blog/images/inkpaper/circle.png)\n\n文章撰写分可视化与Markdown视图，可在右侧即时切换，可视化视图中使用类Medium的行内弹出式工具栏形式。\n\n![文章撰写视图，初始化](/blog/images/inkpaper/edit_blank.png)\n\n![文章撰写视图，类Medium格式工具栏](/blog/images/inkpaper/edit_toolbar.png)\n\n![文章撰写视图，添加图片，音乐与视频工具栏](/blog/images/inkpaper/edit_add.png)\n\n![个人文章视图](/blog/images/inkpaper/person.png)\n\n![设置视图](/blog/images/inkpaper/setting.png)\n\n![设置视图，多条目输入](/blog/images/inkpaper/setting_more.png)\n\n![移动端启动屏，最初的拟定名片时文书](/blog/images/inkpaper/mobile.jpg)\n\nWeb前端与后端源码: [https://github.com/imeoer/bamboo](https://github.com/imeoer/bamboo)\n\n项目失败了，收获很多，应该舍弃一些不成熟的想法，设想与解决问题更多的考虑全局，更多以产品而不是实现的角度考虑问题。\n\n在这里推荐一本最近在看的，也是程序/产品都可以看看的书：[《增长黑客》](http://www.zengzhangheike.com/)\n\n\u003e 衍生的博客项目[纸小墨](http://www.inkpaper.io/index-zh.html)参与了100Offer举办的活动，欢迎帮忙[围观](http://i.100offer.com/projects/72)呀\n","cover":"/blog/images/inkpaper/bg.jpg","link":"inkpaper-project.html","preview":"\u003cp\u003e2014年上半年，我和同班毕业的小伙伴发起了一个业余小组的内容发布平台项目。创建一个类似Medium、简书的写作与阅读平台，专注改善文章撰写、阅读的交互体验，优化知识类文章发布与分享方式\u003c/p\u003e\n","title":"一个写作与阅读平台的设计，初版纸小墨"},{"content":"\n\n\u003e 题图来自《阳光中的青时雨》宣传海报。\n\n近几年关注过的动画短片推荐，这些动画短片是独立动画或一些实验性质作品，创作者不少是很有实力的年轻制作人。\n\n### 爷爷的煤油灯\n\n[http://movie.douban.com/subject/6001038/](http://movie.douban.com/subject/6001038/)\n\n![](/blog/images/animation/4.jpg)\n\n### 文子的告白\n\n[http://movie.douban.com/subject/4135702/](http://movie.douban.com/subject/4135702/)\n\n![](/blog/images/animation/5.jpg)\n\n### 阿茹茉妮\n\n[http://movie.douban.com/subject/24706479/](http://movie.douban.com/subject/24706479/)\n\n![](/blog/images/animation/3.jpg)\n\n### 阳光中的青时雨\n\n[http://movie.douban.com/subject/25739151/](http://movie.douban.com/subject/25739151/)\n\n![](/blog/images/animation/6.jpg)\n\n### 勿忘蛛\n\n[http://movie.douban.com/subject/10574474/](http://movie.douban.com/subject/10574474/)\n\n![](/blog/images/animation/2.jpg)\n\n### 猫的集会\n\n[http://movie.douban.com/subject/21945191/](http://movie.douban.com/subject/21945191/)\n\n![](/blog/images/animation/1.jpg)\n\n### 小魔女学园\n\n不定期更新。\n","cover":"/blog/images/animation/shashinkan.jpg","link":"animated-short-film.html","preview":"\u003cp\u003e近几年关注过的动画短片推荐，这些动画短片是独立动画或一些实验性质作品，创作者不少是很有实力的年轻制作人\u003c/p\u003e\n","title":"优秀的独立或实验性动画短片推荐"},{"content":"\n\n## 简介\n\nBuild是一个使用GO语言编写的自动化任务构建工具，可根据描述配置执行任务。类似于JavaScript中的Grunt与Gulp工具，但更加简单，不需要编写复杂的逻辑代码。\n\n## 简单示例\n\n以下例子描述了当web目录(/path/web)下任意.go文件发生变化时，自动执行名为build的任务，即切换到web目录下执行\"go build\"命令。\n\n``` yaml\nvariable:\n    web: \"/path/web\"\ntask:\n    build:\n        - \"cd ${web} \u0026\u0026 go build\"\nwatch:\n    ${web}/*.go: \"${build}\"\n```\n\n## 介绍\n\nBuild使用YAML格式的配置文件来描述任务，分为**变量**(variable)，**任务**(task)，**监控**(watch)三个字段。\n\n### 变量(variable)\n\n变量定义了需要在任务或监控字段中可替换的字符串，变量中也可引用其他变量。\n\n### 任务(task)\n\n任务是按顺序执行的Shell命令，或引用的其他任务。若在引用的任务名前加```#```，表示该任务是非阻塞的，Build不会等待该任务完成，而是继续执行后面的任务。\n\n### 监控(watch)\n\n当任意文件发生变化时，执行任务中定义的任务，其中可以引用变量。\n\n## 复杂示例\n\n定义了两个变量，其中path1是/a/b，path2则是/a/b/c\n\n定义了三个任务，其中default是默认任务，```build```命令会执行该任务，而```build develop```与```build commit```命令则分别执行develop与commit任务。default任务中，会并发执行develop与commit任务\n\n定义了一个监控，当/a/b/c/*.go文件发生变化时，执行develop任务\n\n``` yaml\nvariable:\n    path1: \"/a/b\"\n    path2: \"${path1}/c\"\ntask:\n    default:\n        - \"${#develop}\"\n        - \"${commit}\"\n    develop:\n        - \"cd ${path1} \u0026\u0026 go build\"\n        - \"${path1}/program\"\n    commit:\n        - \"cd ${path1} \u0026\u0026 git push origin\"\nwatch:\n    ${path1}/*.go: \"${develop}\"\n```\n\n## 使用命令\n\n``` shell\nbuild [-c build.yml] [-s] [-k] [task name]\n```\n\n```-c```指定配置文件目录，若不指定，则使用当前目录的build.yml\n\n```-s```指定在执行任务时，不输出日志\n\n```-k```指定在监控到文件变化后，不清空输出的日志\n\n最后指定任务名称，若不指定将执行default任务\n\n## 源码\n\n[https://github.com/InkProject/build.go](https://github.com/InkProject/build.go)\n\nClone代码后，使用```go build build.go```命令编译，获得名为```build```的可执行文件\n","cover":"","link":"golang-build-tool.html","preview":"\u003cp\u003eBuild是一个使用GO语言编写的自动化任务构建工具，可根据描述配置执行任务。类似于JavaScript中的Grunt与Gulp工具，但更加简单，不需要编写复杂的逻辑代码\u003c/p\u003e\n","title":"简洁的自动化任务构建工具"},{"content":"\n\n初中开始喜欢上画画，从画给同学看的火柴小人剪纸小故事本，到现在的软件绘画，看到流畅优雅的线稿总觉得好美，禁不住想要去临摹，当然到能熟练原创还需要很多很多的练习，需要超强的构图与想象力。总之加油吧！祭上很久以前临摹与胡乱的图。\n\n![高中时期的东方临摹](/blog/images/paint/tohou.jpg)\n\n![高中时期的火影临摹](/blog/images/paint/naruto.jpg)\n\n![送给高中好友的画](/blog/images/paint/gift.jpg)\n\n![涂鸦幸运星](/blog/images/paint/luckstar.jpg)\n\n![涂鸦头像，来自黑执事](/blog/images/paint/head.jpg)\n\n![柯南海报临摹](/blog/images/paint/konan.png)\n\n![数位板练习](/blog/images/paint/study.jpg)\n\n![蝴蝶少女，数位板练习](/blog/images/paint/butterfly.jpg)\n\n![钢炼FA全人物海报，鼠绘](/blog/images/paint/fa_full.jpg)\n\n![让我取暖，数位板练习](/blog/images/paint/warm.jpg)\n\n![仿新海诚云的画法，PS鼠绘](/blog/images/paint/sky.jpg)\n\n![钢豆丁，铅笔稿](/blog/images/paint/fa.jpg)\n\n![中二度满满的知乎娘设计](/blog/images/paint/zhihu.jpg)\n\n![起风了临摹线稿+水彩](/blog/images/paint/wind1.jpg)\n\n![](/blog/images/paint/wind2.jpg)\n\n![](/blog/images/paint/wind3.jpg)\n","cover":"/blog/images/paint/konan.png","link":"some-copied-paint.html","preview":"\u003cp\u003e初中开始喜欢上画画，从画给同学看的火柴小人剪纸小故事本，到现在的软件绘画，看到流畅优雅的线稿总觉得好美，禁不住想要去临摹\u003c/p\u003e\n","title":"很久前的一些绘画临摹稿"},{"content":"\n\n### 出行准备\n日本是我一直想去也是唯一特别想去的地方，这是个安静的，文化沿袭深厚的国家，更因为ACG宅的二次元情结，11区是绝对的巡礼圣地。\n\n护照签证经历麻烦了些，自由行签证只能委托旅行社办，每家旅行社要求材料不一，因为条件不充足，最后交了押金证明才出签。实际日本使馆签证要求并没那么高，有过一次签证经历后，再办应该会简单很多。\n\n最想去的便是东京的吉卜力美术馆，拜托同事在日本的朋友订了门票，临行前又很激动地看了一遍千与千寻\u0026龙猫\u0026哈尔的移动城堡，每次看感觉都不一样，总能发现以前没注意过的细节，这就是老爷子作品的魅力吧。500块拿到了同事的松下LX5GK相机，试着拍了几张就感觉赚到了，照片都是用它拍的，非常感谢良心同事。\n\n### 东京\n天津出发，晚上降落关西机场，和两个同事一起在机场休息室过了后半夜（是个收费小网吧）。趴桌上迷迷糊糊醒来，一早换票坐上了去东京的新干线。\n\n![大阪至东京的新干线](/blog/images/japan/482e3c3f81aa0ed6838b7f06b853ec9c.jpg)\n\n![东京站便利店买的一份朝日新闻](/blog/images/japan/6cbbd4e72800ceceba5242ef3376526a.jpg)\n\n![东京站外的广场，深秋雨后落叶撒满一地](/blog/images/japan/8f3f68a75273a8fd359186a608f263f2.jpg)\n\n![去皇居的小路上，满满的杏树](/blog/images/japan/090675ca944a62e8bfc44a1ed61c4bd3.jpg)\n\n![清新的袖珍马路](/blog/images/japan/710d43c8f6808f1d082652c65d18da97.jpg)\n\n![千代田街区，雨后阳光初现](/blog/images/japan/f858480fca78a276a3a82e4d61f319e9.jpg)\n\n![噗，修的稍稍过了](/blog/images/japan/324f59794d0be422c6a0e065b5bf3784.jpg)\n\n![新宿御苑公园](/blog/images/japan/36eb3a95d7ea93e8652afd0378ff7859.jpg)\n\n![言叶之庭中主角避雨的小亭子吗](/blog/images/japan/c082fbc869a531a3ecac507329ce1b1b.jpg)\n\n![整洁安静的十字路口](/blog/images/japan/cefcc5818c6d1a1fa2a3d60916cb7976.jpg)\n\n![赶上下班高峰的电车](/blog/images/japan/bad62f3ff9c22bca8bb42d509d7469a4.jpg)\n\n![抓拍到秋叶原广场的飞鸽](/blog/images/japan/60ff49d0c107320370078f6653edf842.jpg)\n\n![秋叶原书店，幸腹涂鸦海报](/blog/images/japan/93a36bd6d4b3612c82a77f872e759dbd.jpg)\n\n![马猴烧酒小圆脸与黑长直](/blog/images/japan/c436b6526851521647522f03bd022459.jpg)\n\n![期待已久的三鹰之森吉卜力美术馆](/blog/images/japan/2d31545b63942ec49e20dc38dc9ca7bb.jpg)\n\n![馆壁外滕蔓满满，馆内拍照禁止哦](/blog/images/japan/98e0982372aee9fc64562e3bd9ba71f2.jpg)\n\n![天空之城顶层的园丁机器人，孤独地守护到永远](/blog/images/japan/750dd448fa81b3fe37ce56ede2588c9c.jpg)\n\n### 京都\n\n四天的东京行程，晚上匆匆搭上了去大阪的新干线，上午一早来到了京都八坂神社\n\n![神社祈愿](/blog/images/japan/aa7547fcd06bf3b87e285da2a88c5c4b.jpg)\n\n![京都小道上又一番景象](/blog/images/japan/18433a4c3da988f840440799d3fda837.jpg)\n\n![无脸男走错片场啦](/blog/images/japan/ef033cff8c4d0b99c804a9436b9e0c4c.jpg)\n\n![一只飞翔的龙猫](/blog/images/japan/d8ac54a1ff4012c1dc7c96f594cf5e33.jpg)\n\n![魔女宅急便](/blog/images/japan/fbb3f635fa9984cf92c7bb7e01c85be9.jpg)\n\n### 大阪\n\n![日本桥绘师KANTOKU专卖店，满墙的海报](/blog/images/japan/a4191b5023373ec6f63aa41f70bc5164.jpg)\n\n![伏见稻荷大社，连附近的公司都是古韵满满](/blog/images/japan/3aa04080a8d0cdd9b8ba2cc068e5a903.jpg)\n\n![黄昏下的铁道](/blog/images/japan/77d5a094e6ab2bd997823a1c5d37e57e.jpg)\n\n![黄昏下的铁道](/blog/images/japan/21e35bca4549e2fc6c29f0954c3c071d.jpg)\n\n![放课后骑单车的少年](/blog/images/japan/ed9c7d9cda1084ad1e4a083d3a7d8e7b.jpg)\n\n未完待续...\n","cover":"/blog/images/japan/shrine.jpg","link":"first-japan-travel.html","preview":"\u003cp\u003e日本是我一直想去也是唯一特别想去的地方，这是个安静的，文化沿袭深厚的国家，更因为ACG宅的二次元情结，11区是绝对的巡礼圣地\u003c/p\u003e\n","title":"十一月日本国初行"},{"content":"\n\n## Introduce\n\nInkPaper is an static blog generator developed by Golang, No dependencies, Cross platform, Easy use, Fast build, Elegant theme.\n\n![InkPaper - An Elegant Static Blog Generator](/blog/images/example-en.png)\n\n### Quick Start\n- Download \u0026 Extract [Ink](http://www.chole.io/)，Run `ink preview`\n- Open `http://localhost:8000` in browser to preview\n\n### Website Configuration\nEdit `config.yml`, use format:\n\n``` yaml\nsite:\n    title: Website Title\n    subtitle: Website Subtitle\n    limit: Max Article Count Per Page\n    theme: Website Theme Directory\n    comment: Comment Plugin Variable (Default is disqus username)\n    root: Website Root Path #Optional\n    lang: Website Language #Support en, zh, ru, ja, Configurable in theme/lang.yml\n    url: Website URL #For RSS Generating\n    link: Article Link Scheme #Default Is {title}.html，Support {year},{month},{day},{title} Variables\n\nauthors:\n    AuthorID:\n        name: Author Name\n        intro: Author Motto\n        avatar: Author Avatar Path\n\nbuild:\n    port: Preview Port\n    copy:\n        - Copied Files When Build\n    publish: |\n        Excuted command when use 'ink publish'\n```\n\n### Writing\nCreate any `.md` file in `source` directory (Support subdirectory), use format:\n\n``` yaml\ntitle: Article Title\ndate: Year-Month-Day Hour:Minute:Second #Created Time，Support TimeZone, such as \" +0800\"\nupdate: Year-Month-Day Hour:Minute:Second #Updated Time，Optional，Support TimeZone, such as \" +0800\"\nauthor: AuthorID\ncover: Article Cover Path #Optional\ndraft: false #If Draft，Optional\ntop: false #Place article to top, Optional\npreview: Article Preview，Also use \u003c!--more--\u003e to split in body #Optional\ntags: #Optional\n    - Tag1\n    - Tag2\n\n---\n\nMarkdown Format's Body\n```\n\n### Publish\n- Run `ink publish` in blog directory to automatically build and publish\n- Or run `ink build` to manually deploy generated `public` directory\n\n\u003e **Tips**: When files changed，`ink preview` will automatically rebuild blog，refresh browser to update.\n\n## Customization\n\n### Modify Theme\n\nDefault theme placed in `theme` folder, run `npm install` and `webpack` to rebuild in this folder.\n\npage `page.html` (article list) and `article.html` (article), use variable with [Golang Template](http://golang.org/pkg/html/template/) syntax.\n\n### New Page\n\nCreated any `.html` file will be copied to `source` directory, could use all variables on `site` field in `config.yml`.\n\n### Blog Migrate (Beta)\n\nSupport simple Jeklly/Hexo post convert, use:\n\n``` shell\nink convert /path/_posts\n```\n\n### Build from source\n\nLocal Build\n\n1. Install [Golang](http://golang.org/doc/install) environment\n2. Run `go get github.com/InkProject/ink`, compile and get ink\n3. Run `ink preview $GOPATH/src/github.com/InkProject/ink/template`, preview blog\n\nDocker Build (Example)\n\n1. Clone code `git clone git@github.com:InkProject/ink.git`\n2. Build image `docker build -t ink .` in source directory\n3. Run container `docker run -p 8888:80 ink`\n\n## Theme\n\n- Pure: [https://github.com/Xdatk/ink-pure](https://github.com/Xdatk/ink-pure)\n- Werttin: [https://github.com/Skimige/ink_Werttin](https://github.com/Skimige/ink_Werttin)\n\n## Issue Report\n\n[CC Attribution-NonCommercial License 4.0](https://creativecommons.org/licenses/by-nc/4.0/)\n\n[https://github.com/InkProject/ink/issues](https://github.com/InkProject/ink/issues)\n\n## Change Log\n\n- [2016-07-11] Fix bugs and merge many PRs\n- [2015-08-15] Bug fix, support RSS feed, improve theme\n- [2015-07-04] Bug fix, improve theme, support top, i18n, subtemplate\n- [2015-06-04] Build more platform, add archive and tag page\n- [2015-03-01] Release first beta version\n\n## Develop Plan\n\n- Improve Theme\n- InkPaper Editor\n\n## They are using\n\n- [http://www.chole.io/blog/](http://www.chole.io/blog/)\n- [http://blog.hyper.sh/](http://blog.hyper.sh/)\n- [http://wangxu.me/](http://wangxu.me/)\n- [http://whzecomjm.com/](http://whzecomjm.com/)\n","cover":"/blog/images/example-en.png","link":"ink-blog-tool-en.html","preview":"\u003cp\u003eInkPaper is an static blog generator developed by Golang, No dependencies, Cross platform, Easy use, Fast build, Elegant theme.\u003c/p\u003e\n","title":"An Elegant Static Blog Generator —— InkPaper"},{"content":"\n\n## 纸小墨简介\n\n纸小墨（InkPaper）是一个GO语言编写的开源静态博客构建工具，可以快速搭建博客网站。它无依赖跨平台，配置简单构建快速，注重简洁易用与更优雅的排版。\n\n![纸小墨 - 简洁的静态博客构建工具](/blog/images/example.png)\n\n### 开始上手\n- 下载并解压 [纸小墨](http://www.chole.io/)，运行命令 `ink preview`。\n- 使用浏览器访问 `http://localhost:8000` 预览。\n\n### 特性介绍\n- YAML格式的配置\n- Markdown格式的文章\n- 无依赖跨平台\n- 超快的构建速度\n- 不断改善的主题与排版\n- 多文章作者支持\n- 归档与标签自动生成\n- 保存时实时预览页面\n- 离线的全文关键字搜索\n\n### 配置网站\n编辑`config.yml`，使用如下格式：\n\n``` yaml\nsite:\n    title: 网站标题\n    subtitle: 网站子标题\n    limit: 每页可显示的文章数目\n    theme: 网站主题目录\n    comment: 评论插件变量(默认为Disqus账户名)\n    root: 网站根路径 #可选\n    lang: 网站语言 #支持en, zh, ru, ja，可在theme/config.yml配置\n    url: 网站链接 #用于RSS生成\n    link: 文章链接形式 #默认为{title}.html，支持{year},{month},{day},{title}变量\n\nauthors:\n    作者ID:\n        name: 作者名称\n        intro: 作者简介\n        avatar: 作者头像路径\n\nbuild:\n    port: 预览端口\n    copy:\n        - 构建时将会复制的目录/文件\n    publish: |\n        ink publish 命令将会执行的脚本\n```\n\n### 创建文章\n在`source`目录中建立任意`.md`文件（可置于子文件夹），使用如下格式：\n\n``` yaml\ntitle: 文章标题\ndate: 年-月-日 时:分:秒 #创建时间，可加时区如\" +0800\"\nupdate: 年-月-日 时:分:秒 #更新时间，可选，可加时区如\" +0800\"\nauthor: 作者ID\ncover: 题图链接 #可选\ndraft: false #草稿，可选\ntop: false #置顶文章，可选\npreview: 文章预览，也可在正文中使用\u003c!--more--\u003e分割 #可选\ntags: #可选\n    - 标签1\n    - 标签2\n\n---\n\nMarkdown格式的正文\n```\n\n### 发布博客\n- 在博客目录下运行`ink publish`命令自动构建博客并发布。\n- 或运行`ink build`命令将生成的`public`目录下的内容手动部署。\n\n\u003e Tips: 在使用`ink preview`命令时，编辑保存文件后，博客会自动重新构建并刷新浏览器页面。\n\n## 定制支持\n\n### 修改主题\n\n默认主题在`theme`目录下，修改源代码后在该目录下运行`npm install`与`webpack`重新构建。\n\n页面包含`page.html`（文章列表）及`article.html`（文章）等，所有页面均支持[GO语言HTML模板](http://golang.org/pkg/html/template/)语法，可引用变量。\n\n### 添加页面\n\n在`source`目录下创建的任意`.html`文件将被复制，这些文件中可引用`config.yml`中site字段下的所有变量。\n\n### 博客迁移(Beta)\n\n纸小墨提供简单的Jeklly/Hexo博客文章格式转换，使用命令：\n``` shell\nink convert /path/_posts\n```\n\n### 源码编译\n\n本地运行\n\n1. 配置[GO](http://golang.org/doc/install)语言环境。\n2. 运行命令`go get github.com/InkProject/ink`，编译并获取ink。\n3. 运行命令`ink preview $GOPATH/src/github.com/InkProject/ink/template`，预览博客。\n\nDocker构建（示例）\n\n1. Clone源码 `git clone git@github.com:InkProject/ink.git`。\n2. 源码目录下构建镜像`docker build -t ink .`。\n3. 运行容器`docker run -p 8000:80 ink`。\n\n## 三方主题\n\n- Pure: [https://github.com/Xdatk/ink-pure](https://github.com/Xdatk/ink-pure)\n- Werttin: [https://github.com/Skimige/ink_Werttin](https://github.com/Skimige/ink_Werttin)\n\n## 反馈贡献\n\n纸小墨基于 [CC Attribution-NonCommercial License 4.0](https://creativecommons.org/licenses/by-nc/4.0/) 协议，目前为止它仍然是个非成熟的开源项目，非常欢迎任何人的任何贡献。如有问题可报告至 [https://github.com/InkProject/ink/issues](https://github.com/InkProject/ink/issues)。\n\n## 更新历史\n\n- [2016-07-11] 修复诸多Issue与合并一些PR。\n- [2015-08-15] 一些Bug修复，新增RSS订阅支持，主题改善。\n- [2015-07-04] 数项Bug修复与主题改善，支持置顶，多语言，子模板。\n- [2015-06-04] 编译更多平台版本，增加标签与存档页。\n- [2015-03-01] Beta版本，基础功能完成。\n\n## 更新计划\n\n- 排版深度优化\n- 纸小墨编辑器\n\n## 正在使用\n\n- [http://www.chole.io/blog/](http://www.chole.io/blog/)\n- [http://blog.hyper.sh/](http://blog.hyper.sh/)\n- [http://wangxu.me/](http://wangxu.me/)\n- [http://whzecomjm.com/](http://whzecomjm.com/)\n","cover":"/blog/images/example.png","link":"ink-blog-tool.html","preview":"\u003cp\u003e纸小墨（InkPaper）是一个GO语言编写的开源静态博客构建工具，可以快速搭建博客网站。它无依赖跨平台，配置简单构建快速，注重简洁易用与更优雅的排版。\u003c/p\u003e\n","title":"简洁的静态博客构建工具 —— 纸小墨（InkPaper）"},{"content":"\n\n大学做了很多好玩的小玩具，大部分时间花在桌面APP开发和做视频上了，怀念那时的时光，熬夜调试，写界面，和小伙伴们通宵做视频，回头看过来虽然很中二很幼稚，但那时候是开心的，现在有更好的条件了，能做更多的事情了，但留给自己的时间越来越少，那时候的感觉似乎再也找不到了。\n\n![幻境拨号精灵，一个为了校园宽带共享上网的软件，VisualBasic，迭代了N次，服务了很多同学](/blog/images/colloge/dial.jpg)\n\n![幻境电台精灵，一时兴起想听国外电台节目写的电台软件，VisualBasic](/blog/images/colloge/radio.jpg)\n\n![任务魔法盒子，类似IFTTT的桌面版，C++ \u0026 MFC](/blog/images/colloge/box.png)\n\n![任务魔法盒子Android端](/blog/images/colloge/box_mobile.png)\n\n![电子签章平台，Node.js + MongoDB](/blog/images/colloge/sign.png)\n\n集群性能WEB监控： Node.js，MFC，[实现简介](https://drive.google.com/file/d/0B8W2neTuEiYGZDVfN1NxVE5sWTQ/view)\n\n毕业纪念MV： iPad, AfterEffect，[链接](http://v.youku.com/v_show/id_XMTI2NDc0ODU2OA==.html)\n","cover":"","link":"college-works.html","preview":"\u003cp\u003e大学做了很多好玩的小玩具，大部分时间花在桌面APP开发和做视频上了，怀念那时的时光，熬夜调试，写界面，和小伙伴们通宵做视频，回头看过来虽然很中二很幼稚，但那时候是开心的，现在有更好的条件了，能做更多的事情了，但留给自己的时间越来越少，那时候的感觉似乎再也找不到了\u003c/p\u003e\n","title":"纪念有趣过的时光"},{"content":"\n\n## 联系方式\n\n- Email：imeoer@gmail.com\n\n## 个人信息\n\n- 男 / 1990 / 6年工作经验（2012-2018）\n- 西南科技大学（2009-2013） / 信息安全 \u0026 软件工程 / 本科\n- 博客：http://www.chole.io/blog/\n- Github：https://github.com/imeoer\n- Behance: https://www.behance.net/imeoer\n- 意向职位：后端 / 全栈工程师\n- 城市：成都 / 远程\n\n## 工作经历\n\n### 成都 - 远程 - HyperHQ - 全栈工程师 （2016年4月）\n\n- [Function Service](https://docs.hyper.sh/Feature/container/func.html)，[Serverless](https://github.com/hyperhq/faas-hyper)，[Kubernetes](https://github.com/hyperhq/hyper.sh-connector-k8s) 中间件开发。技术栈：Node.js, Koa, Golang, TypeScript, Kafka, MongoDB\n\n- [Hyper.sh](https://www.hyper.sh/) 前端负责，主导 Console，网站架构，UI，计费支付设计与开发，项目管理。技术栈：Node.js，Koa, ES2015+, React, Antd, PostCSS, Webpack, MongoDB，Illustrator\n\n### 北京 - VisualOps（2013年3月 - 2016年3月）\n\n- [VisualOps](http://www.visualops.io/) AWS 与 OpenStack 平台大型 SPA 应用，参与前期架构设计，界面组件与主要业务实现与重构，后期负责部分 UI \u0026 UX 设计。技术栈：CoffeeScript, Backbone.js，Node.js，jQuery，RequireJS, Gulp, ActionScript。\n\n- [CloudFielder](https://www.behance.net/gallery/43178375/Cloud-Fielder-Website) 云计算资源监控平台，项目 Leader，负责全站 UI 设计及项目管理，DSL 解析实现。技术栈：Node.js，Express.js，Ember.js, Gulp，Illustrator。\n\n- 毕业加入的创业公司，在技术、团队协作、项目快速迭代等方面收获很多。熟悉 AWS 平台基础设施开发与使用，大型前端应用研发。\n\n## 业余独立项目\n\n- 纸小墨：静态博客构建与写作工具，Golang，Electron，[http://www.chole.io/](http://www.chole.io/)\n- UI 设计相关：[https://www.behance.net/imeoer](https://www.behance.net/imeoer)\n- Bamboo：撰写阅读与内容发布平台，Backbone.js，Node.js：[设计简介](http://www.chole.io/blog/inkpaper-project.html)\n- Chole: 内网映射工具，Golang, Node.js, Vue.js，[https://github.com/imeoer/chole](https://github.com/imeoer/chole)\n\n## 大学独立项目\n\n- 独立项目：[http://www.chole.io/blog/college-works.html](http://www.chole.io/blog/college-works.html)\n- 幻境拨号精灵：西南校园宽带与路由拨号器，加密算法，VisualBasic\n- 任务魔法盒子：IFTTT桌面版，创意，UI 与界面实现，VisualBasic\n- ARP网络攻击工具：协议与抓包分析，Visual C++ MFC\n- 集群性能WEB监控应用：Node.js，MFC，[实现简介](https://drive.google.com/file/d/0B8W2neTuEiYGZDVfN1NxVE5sWTQ/view)\n- 电子签章平台：Web 平台研发，UI 与前后端实现，Node.js，Java，MongoDB\n- 创意设计与开发团队：团队队长，主接 UI 设计，AE 视频，网站安全测试项目\n- NOC 全国网络与信息安全技术大赛一等奖，团队领队\n\n## 技术关键字\n\n- 熟悉\n\n  - JavaScript, Node.js, Golang\n  - Koa, Vue.js，Electron, React 及其生态系统\n\n- 了解\n\n  - Linux / AWS / Container\n  - Ionic / React Native\n  - MongoDB / Nginx / Redis\n  - C++ / MFC / VisualBasic\n  - Photoshop / Illustrator / Sketch / After Effect / 美术与后期\n\n## 日常与兴趣\n\n\n- VSCode, Github, macOS，Arch Linux\n- Slack, Trello, Telegram\n- ProductHunt, InfoQ, HackerNews\n- Podcast，V2EX，即刻，Twitter\n- Dribbble，Behance\n- ACG，美术，绘画，音乐\n- 视觉，交互与文案设计\n- 关注新技术与创业项目\n","cover":"","link":"resume.html","preview":"","title":"个人简历"}]